#Gabriel Lane
#April 25, 2017
#OpenPalm password generator

"""
OpenPalm is a strong password generator that stores NONE of your personal information or passwords locally.
OpenPalm contains a feature that allows inputs (names of sites or services) to be saved for password generation.
    However, this feature does not save any actual passwords. It simply allows you to regenerate them on the fly.

Simply enter your personal key, and then enter any inputs that you want.
The same personal key and input will generate the same password every time.
However, a slightly different key OR input will generate a RADICALLY DIFFERENT password.

Preconditions:
"dictionary.txt" is a local nonempty text file containing alternating strings and linebreaks ("\n")
    Passwords generated by this program are stronger with a longer dictionary.txt, but entries after the 10,000th line are ignored
Any saved input file is a local nonempty text file containing input strings (characters, numbers, and semicolons) that are seperated by colons
"""

def readsaved(name):
    """
    Procedural Function
    Opens "name".txt and regenerates/prints the password for each saved input in the file
    """
    
    #---------------------------------------Initialization--------------------------------------------------------------|
    
    ErrorMessage = '\n\t\tError: No such file found in local directory.\n\t\tMake sure your the name is formatted as "example" or "example.txt".'
    ErrorMessage2 = '\n\t\tError: This file appears to be formatted incorrectly.\n\t\tPlease insure that the file contains ONLY a sequence of valid inputs, seperated by colons.'
    
    if name.find(".txt") < 0: name += ".txt"    #Insures that name has ".txt" on the end
    try: saved = open(name,"r")                 #Initialize local saved input file, cautiously
    except IOError:                             #If the file does not exist...
        print(ErrorMessage)                         #Throw error message
        return                                      #Return to loop
    
    #---------------------------------------Body------------------------------------------------------------------------|
    
    inputs = saved.read()                       #Create string of inputs in file
    inputs = inputs.split(":")                  #Split up inputs by colons
    inputs.sort()                               #Alphabetize list of inputs
    try:                                        #Cautiously...
        for entry in inputs:                        #For each input...
            print(makepassword(entry))                  #Print its password
    except ValueError:                          #If an error occurs in this process...
        print(ErrorMessage2)                         #Print an error message
    saved.close()                               #Close file
    return                                      #Return to input loop
    

def writesaved(name):
    """
    Procedural Function
    Opens "name".txt and saves the most recent input to that file
    """

    #---------------------------------------Initialization--------------------------------------------------------------|
    
    if name.find(".txt") < 0: name += ".txt"    #Insures that name has ".txt" on the end
    try: saved = open(name,"r")                 #Initialize local saved input file, cautiously
    
    #---------------------------------------New file case---------------------------------------------------------------|
    
    except IOError:                             #If the file does not exist...
        saved = open(name,"w+")                     #Create and open file for writing
        saved.write(lastrealinput)                  #Append last legitimate input to string
        print("\n\t\tCreated a new file, and successfully added "+lastrealinput+".")    #Print confirmation
        saved.close()                               #Close file for writing
        return                                      #Return to input loop
    
    #---------------------------------------Existing file case----------------------------------------------------------|
    
    inputs = saved.read()                       #Create string of inputs in file
    saved.close()                               #Close file for reading
    saved = open(name,"w")                      #Open file for writing
    saved.write(inputs + ":" + lastrealinput)   #Append last legitimate input to string
    print("\n\t\tSuccessfully saved "+lastrealinput+" to file.")    #Print confirmation
    saved.close()                               #Close file for writing
    return                                      #Return to input loop


def makedictionary():
    """
    Fruitful Function
    Opens dictionary.txt, and returns a usable list of the lines in the file
    """
    
    #---------------------------------------Initialization--------------------------------------------------------------|
    
    dictionary = open("dictionary.txt","r")     #Initialize local dictionary file
    linelist = dictionary.readlines()           #Create list of lines in dictionary
    
    #---------------------------------------Regulate length of dictionary list------------------------------------------|

    repair = 9999 - len(linelist)               #Find the number of entries needed to hit 10k
    if repair > 0:                              #If this number is positive...
        for index in range(repair+1):               #Begin adding on duplicate entries, starting with the beginning of the list
            linelist.append(linelist[index])            #   ...

    #---------------------------------------Remove linebreaks from list entries and return------------------------------|
    
    for index in range(len(linelist)):          #For each entry in list...
        word = linelist[index-1]                    #Get the text in that entry
        linelist[index-1] = word[:len(word)-1]      #Remove the last two character (\n) from the entry
    return linelist                             #Return


def codify(inp, numREQ = False, symREQ = False):
    """
    Fruitful Function
    Takes the input string "inp" and converts it into a sequence of four
    procedurally generated words, or three words with numbers and/or symbols
    
    inp: seed string. Different seeds should produce different codes.
         The characters after the semicolon contain information about generation
    numREQ: boolean. If True, the generated password should contain a number, and no fourth word
    symREQ: boolean. If True, the generated password should contain a symbol, and no fourth word
    
    Preconditions:
    inp is a nonempty string containing upper or lowercase letters, numbers, and symbols
    numeral is a boolean
    """
    
    #---------------------------------------Handle Input----------------------------------------------------------------|
    
    SymbolErrorMessage = "Error: Please remove all symbols and spaces from input"   #Soft error definition
    for char in inp:                            #For every character...
        if char not in alphanumbet:                 #If it's not a number or a letter...
            return SymbolErrorMessage                   #Throw a soft error
    
    #---------------------------------------Generate unrefined input code-----------------------------------------------|
    
    num = ""                                    #Take empty string    
    for char in inp:                            #For each character...
        num = num+str(alphanumbet.index(char))       #Add on the string of that character's place in the alphanumeric dictionary
        
    #---------------------------------------Refine length of input code-------------------------------------------------|
    
    while len(num) != 16:                       #Operates until input code is 16 characters long
        if len(num) < 16:                           #If the length is under 16...
            num += str(int(num)*int(num))               #Add on a squared copy of the existing code
        elif len(num) > 16:                         #If it's over 16...
            num = num[2:]                               #Cut off the first character
            
    #---------------------------------------Split input code into 4 code words------------------------------------------|
    
    WC1 = int(num[:4])                          #Get the integer for a set of 4 numeral characters
    WC2 = int(num[4:8])                         #   ...
    WC3 = int(num[8:12])                        #   ...
    WC4 = int(num[12:])                         #   ...
    W1 = linelist[WC1].title()                  #Get the word found at the #(integer) line of the text file
    W2 = linelist[WC2].title()                  #   ...
    W3 = linelist[WC3].title()                  #   ...
    W4 = linelist[WC4].title()                  #   ...
        
    
    #---------------------------------------Return as four words--------------------------------------------------------|
    
    if numREQ == False and symREQ == False:     #If numerals and symbols were not requested...
        return W1+W2+W3+W4                          #Collate words + return
        
    #---------------------------------------Return as three words with number and/or symbol(s)--------------------------|
    
    string = W1+W2+W3                           #Create string made of first three words. Used if sysREQ is F but numREQ is T
    if symREQ == True:                                                                      #If symbols were requested
        special = {1:"!", 2:"?", 3:"&", 4:",", 5:"-", 6:";", 7:"...", 8:"(", 9:">", 0:'"'}      #Assign special character dictionary
        symbol = special[int(num[13])]                                                          #Choose a character from dictionary using 14th integer of input code
        specialcompanion = {1:"", 2:"", 3:"", 4:"", 5:"", 6:"", 7:"", 8:")", 9:"", 0:'"'}       #Assign rare dictionary of character pairs
        location = {1:symbol+W1+W2+W3, 2:symbol+W1+W2+W3, 3:symbol+W1+W2+W3,                    #Assign dictionary of symbol placements
                    4:W1+symbol+W2+W3, 5:W1+symbol+W2+W3,                                       #   ...
                    6:W1+W2+symbol+W3, 7:W1+W2+symbol+W3,                                       #   ...
                    8:W1+W2+W3+symbol, 9:W1+W2+W3+symbol, 0:W1+W2+W3+symbol}                    #   ...
        string = location[int(num[14])]                                                         #Choose a symbol placement using 15th integer of input code
        string = string + specialcompanion[int(num[13])]                                        #Add the character pair, if applicable (parens and quotes). Override existing string
    if numREQ == True:                          #If numerals were requested             
        string += num[12]                           #Add the 13th integer of input code
    return string                               #Return


def scramble(key):
    """
    Fruitful Function
    Scramble the global character list using your personal key ("key") as a seed
    
    key: input seed
    
    Preconditions:
    key is a possibly empty string containing upper and lowercase letters, and numerals
    """
    
    #---------------------------------------Initial variable assignment-------------------------------------------------|

    characters = ["a","b","c","d","e","f",      #Assign alphabet list
                  "g","h","i","j","k","l",      #   ...
                  "m","n","o","p","q","r",      #   ...
                  "s","t","u","v","w","x",      #   ...
                  "y","z"]                      #   ...
    numbers = ["1","2","3","4","5","6","7",     #Assign numeral list
               "8","9","0"]                     #   ...

    #---------------------------------------Scramble Alphabet and return------------------------------------------------|

    key = key.lower()                           #Insure lowercase
    for char in key:                            #For each character in the personal key...
        if char in characters:                      #If the character is a letter...
            split = characters.index(char)              #Find character in alphabet
            second = characters[split:]                 #Take space after letter (including letter)
            first = characters[:split]                  #Take space before letter
            first.reverse()                             #Reverse space before letter
            characters = second+first                   #Recombine in opposite order
        elif char in numbers:                       #If the character is a numeral...
            split = int(char)                           #Find letter at (char) position in alphabet
            second = characters[split:]                 #Take space after letter (including letter)
            first = characters[:split]                  #Take space before letter
            characters = second+first                   #Recombine in opposite order
            second = characters[split:]                 #Take space after letter at (char) position again
            first = characters[:split]                  #Take space before letter
            first.reverse()                             #Reverse space before letter
            characters = second+first                   #Recombine in opposite order
    return characters+numbers                   #Return new combines alphanumeric character list

         
def makepassword(entry):
    """
    Fruitful Function
    Using input 'entry' and the Personal Key dictionary, runs "codify" 10 times in order to create a secure password
    """
    
    #---------------------------------------Initialization--------------------------------------------------------------|
    
    inp = entry.lower()                         #Insure input is lowercase, maintaining "entry" (orginal input)
    semic = inp.find(";")                       #Search for semicolon (between input and special requests)
    n_present = False                           #Assume no special request
    s_present = False                           #   ...
    
    #---------------------------------------Deal with special requests--------------------------------------------------|
    
    if semic > 0:                               #If special requests were made...
        n_present = ("n" in inp[semic:])            #Set request boolean for numerals
        s_present = ("s" in inp[semic:])            #Set request boolean for symbols
        inp = inp[:semic]                           #Remove semicolon and special requests from input
    
    #---------------------------------------Print input feedback string-------------------------------------------------|
    
    if n_present or s_present: suffix = "\t\t\t\t(" #If special requests were made, begin suffix with paren
    else: suffix = ""                           #Otherwise, use a blank suffix
    if n_present: suffix += "numbers"           #If numbers are requested, state
    if n_present and s_present: suffix+= ", "   #If both are requested, use comma
    if s_present: suffix += "symbols"           #If symbols are requested, state
    if n_present or s_present: suffix += ")"    #If special requests were made, end suffix with opposite paren
    if entry.find(";") > 0: entry = entry[:entry.find(";")]     #Remove special requests from original input
    print("\t\t"+entry+suffix)                  #Print statement with original input
    
    #---------------------------------------Run codify loop-------------------------------------------------------------|
        
    for index in range(9):                      #For security and unpredictability, run nine times
        inp = codify(inp)                               #Re-codify input
        #print(inp)                                     #TESTING; print inp after every loop
        inp = inp.lower()                               #Insure lowercase
    return "\t\t\t"+codify(inp,n_present,s_present)     #Final codification, using the booleans assigned above 

    

"""SCRIPT"""

#---------------------------------------Variable definition---------------------------------------------|

KeyPrompt = '\nEnter your Personal Key, or "?" for help.'
InputPrompt = '\n\tEnter an Input, or "?" for help. To use another Personal Key, simply press enter.\n\tTo open a group of saved inputs, enter "=", followed by the name of the saved ".txt" file in this folder.\n\tTo save your MOST RECENT input to a file, enter "+", followed by the name of the saved ".txt" file in this folder.'

KeyHelp = "\n\tOpenPalm is a strong password generator that stores NONE of your personal information.\n\tSimply enter your Personal Key, and then enter any inputs, such as the name of a website.\n\tThe same Personal Key and input will generate the same password every time, so there is no need for storage.\n\tHowever, a slightly different key OR input will generate a RADICALLY DIFFERENT password.\n\tYour Personal Key should be a strong password that you can remember, containing many letters and numbers.\n\tCapitalization will be ignored, and symbols or spaces will be omitted."
InputHelp = "\n\t\tInput should be the name of a service or website.\n\t\tLength does not matter in determining strength, so use the most memorable name.\n\n\t\tYour input should contain only letters and numerals, with stray spaces and symbols omitted.\n\t\tTo add modifiers to your password, use a semicolon between the input and your modifiers\n\t\tExample: Gmail;s  or  Gmail;sn\n\n\t\t\t--MODIFIERS--\n\t\t\tn - include a numeral in the generated password\n\t\t\ts - include a symbol in the generated password"
InputHelp2 = '\n\n\t\tWhen adding to a save file (using "+FileName" or "+FileName.txt") the file will be created if it doesnt exist.\n\t\tWhen reading from a file (using "=FileName" or "=FileName.txt") you will see a sorted list of inputs/passwords.\n\t\tRemember that these passwords are generated on the fly using your CURRENT Personal Code!\n\t\tUse the same Personal Code every time you open a file, or incorrect passwords will be shown.'

EmptyError = "\nError: For Security, please enter a nonempty Personal Key"

#---------------------------------------Initialization--------------------------------------------------|

linelist = makedictionary()                     #Initialize dictionary

#---------------------------------------Personal Key loop-----------------------------------------------|

while (True):                                   #Begin user interface loop
    print(KeyPrompt)                                #Prompt Personal Key input
    key = input("> ")                           #Take key input
    if (key == "?"):                                  #If the user requests help...
        print(KeyHelp)                                  #Print help information
    elif (key == "[["):                               #DEVELOPER CASE; If user inputs [[...
        exit()                                          #Close program
    elif (key == ""):                                 #If the user inputs nothing...
        print(EmptyError)                               #Refuse to run input loop
    else:                                           #If the user does not request help...
        alphanumbet = scramble(key)                     #Scramble dictionary using key
        loop = True                                     #Assign detector to keep running input loop
    
#---------------------------------------Input loop------------------------------------------------------|
        
        while (loop == True):                           #Begin input loop
            print(InputPrompt)                              #Prompt input          
            inp = input("\t> ")                         #Take input
            if inp == "":                               #If user input nothing...
                loop = False                                #End input loop, return to Personal Key loop
            elif inp == "[[":                           #DEVELOPER CASE; If user inputs [[...
                exit()                                      #Close program
            elif inp == "?":                            #If the user requests help...
                print(InputHelp+InputHelp2)             #Print help information
            elif inp[0] == "+":                         #If the user requests a file write...
                writesaved(inp[1:])                         #Write the last password input to that file
            elif inp[0] == "=":                         #If the user requests a file read...
                print("")                                   #Spacing
                readsaved(inp[1:])                          #Read and return the inputs in that file
            else:                                       #If the user input something...
                lastrealinput = inp                         #Assign variable for file saving
                print("")                                   #Spacing
                print(makepassword(inp))                    #Generate and print the password
                
                
                


    
    
    
    
